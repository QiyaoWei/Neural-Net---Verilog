// megafunction wizard: %ROM: 1-PORT%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altsyncram 

// ============================================================
// File Name: memory.v
// Megafunction Name(s):
// 			altsyncram
//
// Simulation Library Files(s):
// 			altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 18.0.0 Build 614 04/24/2018 SJ Standard Edition
// ************************************************************


//Copyright (C) 2018  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel FPGA IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Intel and sold by Intel or its authorized distributors.  Please
//refer to the applicable agreement for further details.


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module memory (
	address,
	clock,
	q);

	input	[15:0]  address;
	input	clock;
	output  q;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri1	  clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire sub_wire0;
	wire q = sub_wire0;

	altsyncram	altsyncram_component (
				.address_a (address),
				.clock0 (clock),
				.q_a (sub_wire0),
				.aclr0 (1'b0),
				.aclr1 (1'b0),
				.address_b (1'b1),
				.addressstall_a (1'b0),
				.addressstall_b (1'b0),
				.byteena_a (1'b1),
				.byteena_b (1'b1),
				.clock1 (1'b1),
				.clocken0 (1'b1),
				.clocken1 (1'b1),
				.clocken2 (1'b1),
				.clocken3 (1'b1),
				.data_a (1'b1),
				.data_b (1'b1),
				.eccstatus (),
				.q_b (),
				.rden_a (1'b1),
				.rden_b (1'b1),
				.wren_a (1'b0),
				.wren_b (1'b0));
	defparam
		altsyncram_component.address_aclr_a = "NONE",
		altsyncram_component.clock_enable_input_a = "BYPASS",
		altsyncram_component.clock_enable_output_a = "BYPASS",
		altsyncram_component.init_file = "img_compile.mif",
		altsyncram_component.intended_device_family = "Cyclone V",
		altsyncram_component.lpm_hint = "ENABLE_RUNTIME_MOD=NO",
		altsyncram_component.lpm_type = "altsyncram",
		altsyncram_component.numwords_a = 65536,
		altsyncram_component.operation_mode = "ROM",
		altsyncram_component.outdata_aclr_a = "NONE",
		altsyncram_component.outdata_reg_a = "CLOCK0",
		altsyncram_component.widthad_a = 16,
		altsyncram_component.width_a = 1,
		altsyncram_component.width_byteena_a = 1;

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: ADDRESSSTALL_A NUMERIC "0"
// Retrieval info: PRIVATE: AclrAddr NUMERIC "0"
// Retrieval info: PRIVATE: AclrByte NUMERIC "0"
// Retrieval info: PRIVATE: AclrOutput NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_ENABLE NUMERIC "0"
// Retrieval info: PRIVATE: BYTE_SIZE NUMERIC "8"
// Retrieval info: PRIVATE: BlankMemory NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_A NUMERIC "0"
// Retrieval info: PRIVATE: Clken NUMERIC "0"
// Retrieval info: PRIVATE: IMPLEMENT_IN_LES NUMERIC "0"
// Retrieval info: PRIVATE: INIT_FILE_LAYOUT STRING "PORT_A"
// Retrieval info: PRIVATE: INIT_TO_SIM_X NUMERIC "0"
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: PRIVATE: JTAG_ENABLED NUMERIC "0"
// Retrieval info: PRIVATE: JTAG_ID STRING "NONE"
// Retrieval info: PRIVATE: MAXIMUM_DEPTH NUMERIC "0"
// Retrieval info: PRIVATE: MIFfilename STRING "img_0.mif"
// Retrieval info: PRIVATE: NUMWORDS_A NUMERIC "65536"
// Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC "0"
// Retrieval info: PRIVATE: RegAddr NUMERIC "1"
// Retrieval info: PRIVATE: RegOutput NUMERIC "1"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: PRIVATE: SingleClock NUMERIC "1"
// Retrieval info: PRIVATE: UseDQRAM NUMERIC "0"
// Retrieval info: PRIVATE: WidthAddr NUMERIC "16"
// Retrieval info: PRIVATE: WidthData NUMERIC "196"
// Retrieval info: PRIVATE: rden NUMERIC "0"
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: ADDRESS_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: CLOCK_ENABLE_OUTPUT_A STRING "BYPASS"
// Retrieval info: CONSTANT: INIT_FILE STRING "img_0.mif"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: CONSTANT: LPM_HINT STRING "ENABLE_RUNTIME_MOD=NO"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altsyncram"
// Retrieval info: CONSTANT: NUMWORDS_A NUMERIC "65536"
// Retrieval info: CONSTANT: OPERATION_MODE STRING "ROM"
// Retrieval info: CONSTANT: OUTDATA_ACLR_A STRING "NONE"
// Retrieval info: CONSTANT: OUTDATA_REG_A STRING "CLOCK0"
// Retrieval info: CONSTANT: WIDTHAD_A NUMERIC "16"
// Retrieval info: CONSTANT: WIDTH_A NUMERIC "196"
// Retrieval info: CONSTANT: WIDTH_BYTEENA_A NUMERIC "1"
// Retrieval info: USED_PORT: address 0 0 16 0 INPUT NODEFVAL "address[15..0]"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT VCC "clock"
// Retrieval info: USED_PORT: q 0 0 196 0 OUTPUT NODEFVAL "q[195..0]"
// Retrieval info: CONNECT: @address_a 0 0 16 0 address 0 0 16 0
// Retrieval info: CONNECT: @clock0 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: q 0 0 196 0 @q_a 0 0 196 0
// Retrieval info: GEN_FILE: TYPE_NORMAL memory.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL memory.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL memory.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL memory.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL memory_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL memory_bb.v TRUE
// Retrieval info: LIB_FILE: altera_mf

//--------------------------------------------------------------------------------------------------------------------------------------------------------------
//above are Quartus generated modules. No comments to be made
//below is a simplified implementation of a hand-written digit recognition neural network
//The top module is top_neuron, and under it is---
//1. 65536x1 ROM memory module automatically generated by Quartus
//2. FSM modules neuron, neuron_data_path, and neuron_control_path
//3. Computational modules multiply_by_weights, add_with_bias, activation_function, derivatives, deltas, update_weights, update_bias
//We must hard-code each of the neurons in the network because we want to keep track of the signed bit. Therefore each is a separate bus, and also the length of the program
//Please enjoy

module top_neuron(KEY, CLOCK_50); //top_entity_module
	input CLOCK_50;
	input [3:0] KEY;

	wire reset_h;
	assign reset_h = KEY[0]; //Don't forget to invert this when on FPGA

	//This is hard-coded expected-outputs for 120 images. 120*10 = 1200 bits
	wire [1199:0] expected_values; //1, 0, 1, 4, 0, 0, 7, 3, 5, 3, 8, 9, 1, 3, 3, 1, 2, 0, 7, 5, 8, 6, 2, 0, 2, 3, 6, 9, 9, 7, 8, 9, 4, 9, 2, 1, 3, 1, 1, 4, 9, 1, 4, 4, 2, 6, 3, 7, 7, 4, 7, 5, 1, 9, 0, 2, 2, 3, 9, 1, 3, 1, 5, 0, 6, 3, 4, 8, 1, 0, 3, 9, 6, 2, 6, 4, 7, 1, 4, 1, 5, 4, 8, 9, 2, 9, 9, 8, 9, 4, 3, 6, 4, 6, 2, 9, 1, 2, 0, 5, 9, 2, 7, 7, 2, 8, 8, 5, 0, 6, 0, 0, 2, 9, 0, 4, 7, 7, 1, 5
	assign expected_values = {
10'b0100000000,
10'b1000000000,
10'b0100000000,
10'b0000100000,
10'b1000000000,
10'b1000000000,
10'b0000000100,
10'b0001000000,
10'b0000010000,
10'b0001000000,
10'b0000000010,
10'b0000000001,
10'b0100000000,
10'b0001000000,
10'b0001000000,
10'b0100000000,
10'b0010000000,
10'b1000000000,
10'b0000000100,
10'b0000010000,
10'b0000000010,
10'b0000001000,
10'b0010000000,
10'b1000000000,
10'b0010000000,
10'b0001000000,
10'b0000001000,
10'b0000000001,
10'b0000000001,
10'b0000000100,
10'b0000000010,
10'b0000000001,
10'b0000100000,
10'b0000000001,
10'b0010000000,
10'b0100000000,
10'b0001000000,
10'b0100000000,
10'b0100000000,
10'b0000100000,
10'b0000000001,
10'b0100000000,
10'b0000100000,
10'b0000100000,
10'b0010000000,
10'b0000001000,
10'b0001000000,
10'b0000000100,
10'b0000000100,
10'b0000100000,
10'b0000000100,
10'b0000010000,
10'b0100000000,
10'b0000000001,
10'b1000000000,
10'b0010000000,
10'b0010000000,
10'b0001000000,
10'b0000000001,
10'b0100000000,
10'b0001000000,
10'b0100000000,
10'b0000010000,
10'b1000000000,
10'b0000001000,
10'b0001000000,
10'b0000100000,
10'b0000000010,
10'b0100000000,
10'b1000000000,
10'b0001000000,
10'b0000000001,
10'b0000001000,
10'b0010000000,
10'b0000001000,
10'b0000100000,
10'b0000000100,
10'b0100000000,
10'b0000100000,
10'b0100000000,
10'b0000010000,
10'b0000100000,
10'b0000000010,
10'b0000000001,
10'b0010000000,
10'b0000000001,
10'b0000000001,
10'b0000000010,
10'b0000000001,
10'b0000100000,
10'b0001000000,
10'b0000001000,
10'b0000100000,
10'b0000001000,
10'b0010000000,
10'b0000000001,
10'b0100000000,
10'b0010000000,
10'b1000000000,
10'b0000010000,
10'b0000000001,
10'b0010000000,
10'b0000000100,
10'b0000000100,
10'b0010000000,
10'b0000000010,
10'b0000000010,
10'b0000010000,
10'b1000000000,
10'b0000001000,
10'b1000000000,
10'b1000000000,
10'b0010000000,
10'b0000000001,
10'b1000000000,
10'b0000100000,
10'b0000000100,
10'b0000000100,
10'b0100000000,
10'b0000010000};
	wire q;

	//changing image_address and fetching each of the 120 images from memory + passing them into FSM
	reg [99:0] one_image;
	reg [9:0] expected_matrix;
	reg [15:0] image_address;
	reg [9:0] counter;
	reg start;
	reg [5:0] next;
	//This is Quartus-generated memory module
	memory a(
	.address(image_address),
	.clock(CLOCK_50),
	.q(q));

	always @(posedge CLOCK_50)
	begin
		if (reset_h)
		begin
			counter <= 10'd0;
			image_address <= 16'd0;
			one_image <= 100'd0;
			start <= 1'b0;
			next <= 6'd0;
		end
		else if (counter == 10'b0001101110) //adjusted. 100 + 10
		begin
			counter <= 10'd0;
			start <= 1'b1;
			next <= next + 1'b1;
			$display("One image down!");
			$display("%b", one_image);
		end
		else if (counter >= 10'd10) //give the computation modules some time. Otherwise start from 0 and change the "100 + 10" above
		begin
			one_image[10'd109 - counter] <= q;
			image_address <= image_address + 1'b1;
			//duplicated, but necessary
			counter <= counter + 1'b1;
			start <= 1'b0;
		end
		else
		begin
			expected_matrix[10'd9 - counter] <= expected_values[10'd1199 - counter - 6'd10 * next];
			counter <= counter + 1'b1;
			start <= 1'b0;
		end
	end

	//the weights and bias shouldn't be updated when there's a blank image
	always @(*)
	begin
		if (start && one_image == 100'd0)
			start = 1'b0;
	end

	//to store outputs
	wire [3:0] output_weight_neuron_one, output_weight_neuron_two, output_weight_neuron_three, output_weight_neuron_four, output_weight_neuron_five, output_weight_neuron_six, output_weight_neuron_seven, output_weight_neuron_eight, output_weight_neuron_nine, output_weight_neuron_ten;
	wire [9:0] output_bias_neuron_one, output_bias_neuron_two, output_bias_neuron_three, output_bias_neuron_four, output_bias_neuron_five, output_bias_neuron_six, output_bias_neuron_seven, output_bias_neuron_eight, output_bias_neuron_nine, output_bias_neuron_ten;
	//The initial weights and bias are randomized. If the total number of images is not large enough, different random inputs may have some effect
	neuron n(
	.one_image(one_image),
	.start(start),
	.Clock(CLOCK_50),
	.reset_h(reset_h),
	.expected_matrix(expected_matrix),
	.weight_one(4'b1010),
	.weight_two(4'b0101),
	.weight_three(4'b1010),
	.weight_four(4'b1011),
	.weight_five(4'b0100),
	.weight_six(4'b0101),
	.weight_seven(4'b0000),
	.weight_eight(4'b0110),
	.weight_nine(4'b1010),
	.weight_ten(4'b1111),
	.bias_one(10'b1111111111),
	.bias_two(10'b1000100001),
	.bias_three(10'b0010101010),
	.bias_four(10'b0010000011),
	.bias_five(10'b0000100100),
	.bias_six(10'b0101010101),
	.bias_seven(10'b0011000110),
	.bias_eight(10'b0010100001),
	.bias_nine(10'b0101001000),
	.bias_ten(10'b1000011001),
	.output_weight_neuron_one(output_weight_neuron_one),
	.output_weight_neuron_two(output_weight_neuron_two),
	.output_weight_neuron_three(output_weight_neuron_three),
	.output_weight_neuron_four(output_weight_neuron_four),
	.output_weight_neuron_five(output_weight_neuron_five),
	.output_weight_neuron_six(output_weight_neuron_six),
	.output_weight_neuron_seven(output_weight_neuron_seven),
	.output_weight_neuron_eight(output_weight_neuron_eight),
	.output_weight_neuron_nine(output_weight_neuron_nine),
	.output_weight_neuron_ten(output_weight_neuron_ten),
	.output_bias_neuron_one(output_bias_neuron_one),
	.output_bias_neuron_two(output_bias_neuron_two),
	.output_bias_neuron_three(output_bias_neuron_three),
	.output_bias_neuron_four(output_bias_neuron_four),
	.output_bias_neuron_five(output_bias_neuron_five),
	.output_bias_neuron_six(output_bias_neuron_six),
	.output_bias_neuron_seven(output_bias_neuron_seven),
	.output_bias_neuron_eight(output_bias_neuron_eight),
	.output_bias_neuron_nine(output_bias_neuron_nine),
	.output_bias_neuron_ten(output_bias_neuron_ten));
endmodule
//End of top_module and memory modules

//The start of FSM modules
//This is a module that connects the control path and the data path, the remaining two FSM modules
module neuron(one_image, start, Clock, reset_h, weight_one, weight_two, weight_three, weight_four, weight_five, weight_six, weight_seven, weight_eight, weight_nine, weight_ten, bias_one, bias_two, bias_three, bias_four, bias_five, bias_six, bias_seven, bias_eight, bias_nine, bias_ten, expected_matrix, output_weight_neuron_one, output_weight_neuron_two, output_weight_neuron_three, output_weight_neuron_four, output_weight_neuron_five, output_weight_neuron_six, output_weight_neuron_seven, output_weight_neuron_eight, output_weight_neuron_nine, output_weight_neuron_ten, output_bias_neuron_one, output_bias_neuron_two, output_bias_neuron_three, output_bias_neuron_four, output_bias_neuron_five, output_bias_neuron_six, output_bias_neuron_seven, output_bias_neuron_eight, output_bias_neuron_nine, output_bias_neuron_ten);

	input [99:0] one_image;
	input start;
	input Clock;
	input reset_h;

	input [3:0] weight_one, weight_two, weight_three, weight_four, weight_five, weight_six, weight_seven, weight_eight, weight_nine, weight_ten;

	input [9:0] bias_one, bias_two, bias_three, bias_four, bias_five, bias_six, bias_seven, bias_eight, bias_nine, bias_ten;

	input [9:0] expected_matrix;

	output [3:0] output_weight_neuron_one, output_weight_neuron_two, output_weight_neuron_three, output_weight_neuron_four, output_weight_neuron_five, output_weight_neuron_six, output_weight_neuron_seven, output_weight_neuron_eight, output_weight_neuron_nine, output_weight_neuron_ten;
	output [9:0] output_bias_neuron_one, output_bias_neuron_two, output_bias_neuron_three, output_bias_neuron_four, output_bias_neuron_five, output_bias_neuron_six, output_bias_neuron_seven, output_bias_neuron_eight, output_bias_neuron_nine, output_bias_neuron_ten;

	//control signals. Not very useful for now
	wire multiply_by_weights;
	wire add_with_bias;
	wire activation_function;
	wire derivatives;
	wire deltas;
	wire update_weights;
	wire update_bias;

	neuron_control_path a1(
	.start(start),
	.Clock(Clock),
	.reset_h(reset_h),
	.multiply_by_weights(multiply_by_weights),
	.add_with_bias(add_with_bias),
	.activation_function(activation_function),
	.derivatives(derivatives),
	.deltas(deltas),
	.update_weights(update_weights),
	.update_bias(update_bias));

	neuron_data_path a2(
	.Clock(Clock),
	.reset_h(reset_h),
	.input_image(one_image),
	.weight_one(weight_one),
	.weight_two(weight_two),
	.weight_three(weight_three),
	.weight_four(weight_four),
	.weight_five(weight_five),
	.weight_six(weight_six),
	.weight_seven(weight_seven),
	.weight_eight(weight_eight),
	.weight_nine(weight_nine),
	.weight_ten(weight_ten),
	.bias_one(bias_one),
	.bias_two(bias_two),
	.bias_three(bias_three),
	.bias_four(bias_four),
	.bias_five(bias_five),
	.bias_six(bias_six),
	.bias_seven(bias_seven),
	.bias_eight(bias_eight),
	.bias_nine(bias_nine),
	.bias_ten(bias_ten),
	.expected_matrix(expected_matrix),
	.multiply_by_weights(multiply_by_weights),
	.add_with_bias(add_with_bias),
	.activation_function(activation_function),
	.derivatives(derivatives),
	.deltas(deltas),
	.update_weights(update_weights),
	.update_bias(update_bias),
	.output_weight_neuron_one(output_weight_neuron_one),
	.output_weight_neuron_two(output_weight_neuron_two),
	.output_weight_neuron_three(output_weight_neuron_three),
	.output_weight_neuron_four(output_weight_neuron_four),
	.output_weight_neuron_five(output_weight_neuron_five),
	.output_weight_neuron_six(output_weight_neuron_six),
	.output_weight_neuron_seven(output_weight_neuron_seven),
	.output_weight_neuron_eight(output_weight_neuron_eight),
	.output_weight_neuron_nine(output_weight_neuron_nine),
	.output_weight_neuron_ten(output_weight_neuron_ten),
	.output_bias_neuron_one(output_bias_neuron_one),
	.output_bias_neuron_two(output_bias_neuron_two),
	.output_bias_neuron_three(output_bias_neuron_three),
	.output_bias_neuron_four(output_bias_neuron_four),
	.output_bias_neuron_five(output_bias_neuron_five),
	.output_bias_neuron_six(output_bias_neuron_six),
	.output_bias_neuron_seven(output_bias_neuron_seven),
	.output_bias_neuron_eight(output_bias_neuron_eight),
	.output_bias_neuron_nine(output_bias_neuron_nine),
	.output_bias_neuron_ten(output_bias_neuron_ten));
endmodule

module neuron_control_path(start, Clock, reset_h, multiply_by_weights, add_with_bias, activation_function, derivatives, deltas, update_weights, update_bias);

	input start;
	input Clock;
	input reset_h;

	output reg multiply_by_weights;
	output reg add_with_bias;
	output reg activation_function;
	output reg derivatives;
	output reg deltas;
	output reg update_weights;
	output reg update_bias;
	reg hold; //JFFGNG, kind of

	reg [2:0] current_state;
	reg [2:0] next_state;
	localparam HOLD                = 3'b000,
		   MULTIPLY_BY_WEIGHTS = 3'b001,
		   ADD_WITH_BIAS       = 3'b010,
		   ACTIVATION_FUNCTION = 3'b011,
		   DERIVATIVES         = 3'b100,
		   DELTAS              = 3'b101,
		   UPDATE_WEIGHTS      = 3'b110,
		   UPDATE_BIAS         = 3'b111;

	//change state code
	always @(*)
		begin
			case(current_state)
				HOLD               : next_state = start ? MULTIPLY_BY_WEIGHTS : HOLD;
				MULTIPLY_BY_WEIGHTS: next_state = ADD_WITH_BIAS;
				ADD_WITH_BIAS      : next_state = ACTIVATION_FUNCTION;
				ACTIVATION_FUNCTION: next_state = DERIVATIVES;
				DERIVATIVES        : next_state = DELTAS;
				DELTAS             : next_state = UPDATE_WEIGHTS;
				UPDATE_WEIGHTS     : next_state = UPDATE_BIAS;
				UPDATE_BIAS        : next_state = HOLD;
				default            : next_state = HOLD;
			endcase
		end

	//change actual state
	always @(posedge Clock)
		begin
			if (reset_h)
				current_state <= HOLD;
			else
				current_state <= next_state;
		end

	//change state outputs
	always @(*)
		begin
			multiply_by_weights = 1'b0;
			add_with_bias       = 1'b0;
			activation_function = 1'b0;
			derivatives         = 1'b0;
			deltas              = 1'b0;
			update_weights      = 1'b0;
			update_bias         = 1'b0;
			hold                = 1'b0;
			case(current_state)
				MULTIPLY_BY_WEIGHTS: multiply_by_weights = 1'b1;
				ADD_WITH_BIAS      : add_with_bias       = 1'b1;
				ACTIVATION_FUNCTION: activation_function = 1'b1;
				DERIVATIVES        : derivatives         = 1'b1;
				DELTAS             : deltas              = 1'b1;
				UPDATE_WEIGHTS     : update_weights      = 1'b1;
				UPDATE_BIAS        : update_bias         = 1'b1;
				default            : hold                = 1'b1;
			endcase
		end
endmodule

module neuron_data_path(Clock, reset_h, input_image, weight_one, weight_two, weight_three, weight_four, weight_five, weight_six, weight_seven, weight_eight, weight_nine, weight_ten, bias_one, bias_two, bias_three, bias_four, bias_five, bias_six, bias_seven, bias_eight, bias_nine, bias_ten, expected_matrix, multiply_by_weights, add_with_bias, activation_function, derivatives, deltas, update_weights, update_bias, output_weight_neuron_one, output_weight_neuron_two, output_weight_neuron_three, output_weight_neuron_four, output_weight_neuron_five, output_weight_neuron_six, output_weight_neuron_seven, output_weight_neuron_eight, output_weight_neuron_nine, output_weight_neuron_ten, output_bias_neuron_one, output_bias_neuron_two, output_bias_neuron_three, output_bias_neuron_four, output_bias_neuron_five, output_bias_neuron_six, output_bias_neuron_seven, output_bias_neuron_eight, output_bias_neuron_nine, output_bias_neuron_ten);

	input Clock;
	input reset_h;

	input [99:0] input_image;
	input [3:0] weight_one, weight_two, weight_three, weight_four, weight_five, weight_six, weight_seven, weight_eight, weight_nine, weight_ten;
	input [9:0] bias_one, bias_two, bias_three, bias_four, bias_five, bias_six, bias_seven, bias_eight, bias_nine, bias_ten;

	input [9:0] expected_matrix;
	input multiply_by_weights;
	input add_with_bias;
	input activation_function;
	input derivatives;
	input deltas;
	input update_weights;
	input update_bias;

	//we need one set of buses to store the values, and only output if necessary. Otherwise output is maintained
	reg [3:0] weight_neuron_one, weight_neuron_two, weight_neuron_three, weight_neuron_four, weight_neuron_five, weight_neuron_six, weight_neuron_seven, weight_neuron_eight, weight_neuron_nine, weight_neuron_ten;
	reg [9:0] bias_neuron_one, bias_neuron_two, bias_neuron_three, bias_neuron_four, bias_neuron_five, bias_neuron_six, bias_neuron_seven, bias_neuron_eight, bias_neuron_nine, bias_neuron_ten;

	output reg [3:0] output_weight_neuron_one, output_weight_neuron_two, output_weight_neuron_three, output_weight_neuron_four, output_weight_neuron_five, output_weight_neuron_six, output_weight_neuron_seven, output_weight_neuron_eight, output_weight_neuron_nine, output_weight_neuron_ten;
	output reg [9:0] output_bias_neuron_one, output_bias_neuron_two, output_bias_neuron_three, output_bias_neuron_four, output_bias_neuron_five, output_bias_neuron_six, output_bias_neuron_seven, output_bias_neuron_eight, output_bias_neuron_nine, output_bias_neuron_ten;

	//below are executing computations
	wire [9:0] output_from_multiply_by_weights1;
	wire [9:0] output_from_multiply_by_weights2;
	wire [9:0] output_from_multiply_by_weights3;
	wire [9:0] output_from_multiply_by_weights4;
	wire [9:0] output_from_multiply_by_weights5;
	wire [9:0] output_from_multiply_by_weights6;
	wire [9:0] output_from_multiply_by_weights7;
	wire [9:0] output_from_multiply_by_weights8;
	wire [9:0] output_from_multiply_by_weights9;
	wire [9:0] output_from_multiply_by_weights10;

	wire [9:0] output_from_add_with_bias1;
	wire [9:0] output_from_add_with_bias2;
	wire [9:0] output_from_add_with_bias3;
	wire [9:0] output_from_add_with_bias4;
	wire [9:0] output_from_add_with_bias5;
	wire [9:0] output_from_add_with_bias6;
	wire [9:0] output_from_add_with_bias7;
	wire [9:0] output_from_add_with_bias8;
	wire [9:0] output_from_add_with_bias9;
	wire [9:0] output_from_add_with_bias10;

	wire [9:0] output_from_activation_function; //Only one, final output

	wire [9:0] output_from_derivatives1;
	wire [9:0] output_from_derivatives2;
	wire [9:0] output_from_derivatives3;
	wire [9:0] output_from_derivatives4;
	wire [9:0] output_from_derivatives5;
	wire [9:0] output_from_derivatives6;
	wire [9:0] output_from_derivatives7;
	wire [9:0] output_from_derivatives8;
	wire [9:0] output_from_derivatives9;
	wire [9:0] output_from_derivatives10;

	wire [9:0] output_from_deltas1;
	wire [9:0] output_from_deltas2;
	wire [9:0] output_from_deltas3;
	wire [9:0] output_from_deltas4;
	wire [9:0] output_from_deltas5;
	wire [9:0] output_from_deltas6;
	wire [9:0] output_from_deltas7;
	wire [9:0] output_from_deltas8;
	wire [9:0] output_from_deltas9;
	wire [9:0] output_from_deltas10;

	wire [3:0] output_from_update_weights1;
	wire [3:0] output_from_update_weights2;
	wire [3:0] output_from_update_weights3;
	wire [3:0] output_from_update_weights4;
	wire [3:0] output_from_update_weights5;
	wire [3:0] output_from_update_weights6;
	wire [3:0] output_from_update_weights7;
	wire [3:0] output_from_update_weights8;
	wire [3:0] output_from_update_weights9;
	wire [3:0] output_from_update_weights10;

	wire [9:0] output_from_update_bias1;
	wire [9:0] output_from_update_bias2;
	wire [9:0] output_from_update_bias3;
	wire [9:0] output_from_update_bias4;
	wire [9:0] output_from_update_bias5;
	wire [9:0] output_from_update_bias6;
	wire [9:0] output_from_update_bias7;
	wire [9:0] output_from_update_bias8;	
	wire [9:0] output_from_update_bias9;
	wire [9:0] output_from_update_bias10;
	
	//instantiate (seven) modules here
	multiply_by_weights m1(
	.x(input_image),
	.y1(weight_one),
	.y2(weight_two),
	.y3(weight_three),
	.y4(weight_four),
	.y5(weight_five),
	.y6(weight_six),
	.y7(weight_seven),
	.y8(weight_eight),
	.y9(weight_nine),
	.y10(weight_ten),
	.z1(output_from_multiply_by_weights1),
	.z2(output_from_multiply_by_weights2),
	.z3(output_from_multiply_by_weights3),
	.z4(output_from_multiply_by_weights4),
	.z5(output_from_multiply_by_weights5),
	.z6(output_from_multiply_by_weights6),
	.z7(output_from_multiply_by_weights7),
	.z8(output_from_multiply_by_weights8),
	.z9(output_from_multiply_by_weights9),
	.z10(output_from_multiply_by_weights10));

	add_with_bias m2(
	.x1(output_from_multiply_by_weights1),
	.x2(output_from_multiply_by_weights2),
	.x3(output_from_multiply_by_weights3),
	.x4(output_from_multiply_by_weights4),
	.x5(output_from_multiply_by_weights5),
	.x6(output_from_multiply_by_weights6),
	.x7(output_from_multiply_by_weights7),
	.x8(output_from_multiply_by_weights8),
	.x9(output_from_multiply_by_weights9),
	.x10(output_from_multiply_by_weights10),
	.y1(bias_one),
	.y2(bias_two),
	.y3(bias_three),
	.y4(bias_four),
	.y5(bias_five),
	.y6(bias_six),
	.y7(bias_seven),
	.y8(bias_eight),
	.y9(bias_nine),
	.y10(bias_ten),
	.z1(output_from_add_with_bias1),
	.z2(output_from_add_with_bias2),
	.z3(output_from_add_with_bias3),
	.z4(output_from_add_with_bias4),
	.z5(output_from_add_with_bias5),
	.z6(output_from_add_with_bias6),
	.z7(output_from_add_with_bias7),
	.z8(output_from_add_with_bias8),
	.z9(output_from_add_with_bias9),
	.z10(output_from_add_with_bias10));

	activation_function m3(
	.x1(output_from_add_with_bias1),
	.x2(output_from_add_with_bias2),
	.x3(output_from_add_with_bias3),
	.x4(output_from_add_with_bias4),
	.x5(output_from_add_with_bias5),
	.x6(output_from_add_with_bias6),
	.x7(output_from_add_with_bias7),
	.x8(output_from_add_with_bias8),
	.x9(output_from_add_with_bias9),
	.x10(output_from_add_with_bias10),
	.y(output_from_activation_function));

	derivatives m4(
	.x1(output_from_add_with_bias1),
	.x2(output_from_add_with_bias2),
	.x3(output_from_add_with_bias3),
	.x4(output_from_add_with_bias4),
	.x5(output_from_add_with_bias5),
	.x6(output_from_add_with_bias6),
	.x7(output_from_add_with_bias7),
	.x8(output_from_add_with_bias8),
	.x9(output_from_add_with_bias9),
	.x10(output_from_add_with_bias10),
	.y(output_from_activation_function),
	.m(expected_matrix),
	.z1(output_from_derivatives1),
	.z2(output_from_derivatives2),
	.z3(output_from_derivatives3),
	.z4(output_from_derivatives4),
	.z5(output_from_derivatives5),
	.z6(output_from_derivatives6),
	.z7(output_from_derivatives7),
	.z8(output_from_derivatives8),
	.z9(output_from_derivatives9),
	.z10(output_from_derivatives10));

	deltas m5(
	.d1(output_from_derivatives1),
	.d2(output_from_derivatives2),
	.d3(output_from_derivatives3),
	.d4(output_from_derivatives4),
	.d5(output_from_derivatives5),
	.d6(output_from_derivatives6),
	.d7(output_from_derivatives7),
	.d8(output_from_derivatives8),
	.d9(output_from_derivatives9),
	.d10(output_from_derivatives10),
	.x1(output_from_add_with_bias1),
	.x2(output_from_add_with_bias2),
	.x3(output_from_add_with_bias3),
	.x4(output_from_add_with_bias4),
	.x5(output_from_add_with_bias5),
	.x6(output_from_add_with_bias6),
	.x7(output_from_add_with_bias7),
	.x8(output_from_add_with_bias8),
	.x9(output_from_add_with_bias9),
	.x10(output_from_add_with_bias10),
	.y(output_from_activation_function),
	.z1(output_from_deltas1),
	.z2(output_from_deltas2),
	.z3(output_from_deltas3),
	.z4(output_from_deltas4),
	.z5(output_from_deltas5),
	.z6(output_from_deltas6),
	.z7(output_from_deltas7),
	.z8(output_from_deltas8),
	.z9(output_from_deltas9),
	.z10(output_from_deltas10));

	update_weights m6(
	.d1(output_from_deltas1),
	.d2(output_from_deltas2),
	.d3(output_from_deltas3),
	.d4(output_from_deltas4),
	.d5(output_from_deltas5),
	.d6(output_from_deltas6),
	.d7(output_from_deltas7),
	.d8(output_from_deltas8),
	.d9(output_from_deltas9),
	.d10(output_from_deltas10),
	.w1(weight_one),
	.w2(weight_two),
	.w3(weight_three),
	.w4(weight_four),
	.w5(weight_five),
	.w6(weight_six),
	.w7(weight_seven),
	.w8(weight_eight),
	.w9(weight_nine),
	.w10(weight_ten),
	.x1(output_from_add_with_bias1),
	.x2(output_from_add_with_bias2),
	.x3(output_from_add_with_bias3),
	.x4(output_from_add_with_bias4),
	.x5(output_from_add_with_bias5),
	.x6(output_from_add_with_bias6),
	.x7(output_from_add_with_bias7),
	.x8(output_from_add_with_bias8),
	.x9(output_from_add_with_bias9),
	.x10(output_from_add_with_bias10),
	.z1(output_from_update_weights1),
	.z2(output_from_update_weights2),
	.z3(output_from_update_weights3),
	.z4(output_from_update_weights4),
	.z5(output_from_update_weights5),
	.z6(output_from_update_weights6),
	.z7(output_from_update_weights7),
	.z8(output_from_update_weights8),
	.z9(output_from_update_weights9),
	.z10(output_from_update_weights10));

	update_bias m7(
	.d1(output_from_deltas1),
	.d2(output_from_deltas2),
	.d3(output_from_deltas3),
	.d4(output_from_deltas4),
	.d5(output_from_deltas5),
	.d6(output_from_deltas6),
	.d7(output_from_deltas7),
	.d8(output_from_deltas8),
	.d9(output_from_deltas9),
	.d10(output_from_deltas10),
	.z1(output_from_update_bias1),
	.z2(output_from_update_bias2),
	.z3(output_from_update_bias3),
	.z4(output_from_update_bias4),
	.z5(output_from_update_bias5),
	.z6(output_from_update_bias6),
	.z7(output_from_update_bias7),
	.z8(output_from_update_bias8),
	.z9(output_from_update_bias9),
	.z10(output_from_update_bias10));

	//temporary storage
	always @(posedge Clock)
		begin
			if (reset_h)
			begin
				weight_neuron_one   <= weight_one;
				weight_neuron_two   <= weight_two;
				weight_neuron_three <= weight_three;
				weight_neuron_four  <= weight_four;
				weight_neuron_five  <= weight_five;
				weight_neuron_six   <= weight_six;
				weight_neuron_seven <= weight_seven;
				weight_neuron_eight <= weight_eight;
				weight_neuron_nine  <= weight_nine;
				weight_neuron_ten   <= weight_ten;
				bias_neuron_one     <= bias_one;
				bias_neuron_two     <= bias_two;
				bias_neuron_three   <= bias_three;
				bias_neuron_four    <= bias_four;
				bias_neuron_five    <= bias_five;
				bias_neuron_six     <= bias_six;
				bias_neuron_seven   <= bias_seven;
				bias_neuron_eight   <= bias_eight;
				bias_neuron_nine    <= bias_nine;
				bias_neuron_ten     <= bias_ten;
			end
			else
			begin
				weight_neuron_one   <= output_from_update_weights1;
				weight_neuron_two   <= output_from_update_weights2;
				weight_neuron_three <= output_from_update_weights3;
				weight_neuron_four  <= output_from_update_weights4;
				weight_neuron_five  <= output_from_update_weights5;
				weight_neuron_six   <= output_from_update_weights6;
				weight_neuron_seven <= output_from_update_weights7;
				weight_neuron_eight <= output_from_update_weights8;
				weight_neuron_nine  <= output_from_update_weights9;
				weight_neuron_ten   <= output_from_update_weights10;
				bias_neuron_one     <= output_from_update_bias1;
				bias_neuron_two     <= output_from_update_bias2;
				bias_neuron_three   <= output_from_update_bias3;
				bias_neuron_four    <= output_from_update_bias4;
				bias_neuron_five    <= output_from_update_bias5;
				bias_neuron_six     <= output_from_update_bias6;
				bias_neuron_seven   <= output_from_update_bias7;
				bias_neuron_eight   <= output_from_update_bias8;
				bias_neuron_nine    <= output_from_update_bias9;
				bias_neuron_ten     <= output_from_update_bias10;
			end
		end

	//output if necessary
	always @(posedge Clock)
		begin
			if (reset_h)
			begin
				output_weight_neuron_one   <= 4'd0;
				output_weight_neuron_two   <= 4'd0;
				output_weight_neuron_three <= 4'd0;
				output_weight_neuron_four  <= 4'd0;
				output_weight_neuron_five  <= 4'd0;
				output_weight_neuron_six   <= 4'd0;
				output_weight_neuron_seven <= 4'd0;
				output_weight_neuron_eight <= 4'd0;
				output_weight_neuron_nine  <= 4'd0;
				output_weight_neuron_ten   <= 4'd0;
				output_bias_neuron_one     <= 10'd0;
				output_bias_neuron_two     <= 10'd0;
				output_bias_neuron_three   <= 10'd0;
				output_bias_neuron_four    <= 10'd0;
				output_bias_neuron_five    <= 10'd0;
				output_bias_neuron_six     <= 10'd0;
				output_bias_neuron_seven   <= 10'd0;
				output_bias_neuron_eight   <= 10'd0;
				output_bias_neuron_nine    <= 10'd0;
				output_bias_neuron_ten     <= 10'd0;
			end
			//if not on hold then safe to update
			else if (multiply_by_weights || add_with_bias || activation_function || derivatives || deltas || update_weights || update_bias)
			begin
				output_weight_neuron_one   <= weight_neuron_one;
				output_weight_neuron_two   <= weight_neuron_two;
				output_weight_neuron_three <= weight_neuron_three;
				output_weight_neuron_four  <= weight_neuron_four;
				output_weight_neuron_five  <= weight_neuron_five;
				output_weight_neuron_six   <= weight_neuron_six;
				output_weight_neuron_seven <= weight_neuron_seven;
				output_weight_neuron_eight <= weight_neuron_eight;
				output_weight_neuron_nine  <= weight_neuron_nine;
				output_weight_neuron_ten   <= weight_neuron_ten;
				output_bias_neuron_one     <= bias_neuron_one;
				output_bias_neuron_two     <= bias_neuron_two;
				output_bias_neuron_three   <= bias_neuron_three;
				output_bias_neuron_four    <= bias_neuron_four;
				output_bias_neuron_five    <= bias_neuron_five;
				output_bias_neuron_six     <= bias_neuron_six;
				output_bias_neuron_seven   <= bias_neuron_seven;
				output_bias_neuron_eight   <= bias_neuron_eight;
				output_bias_neuron_nine    <= bias_neuron_nine;
				output_bias_neuron_ten     <= bias_neuron_ten;
			end
		end
endmodule
//End of FSM and higher-level modules.
//Starting computation modules, consisting of seven parts (each part can have more than one module)---
//multiply_by_weights, add_with_bias, activation_function, derivatives, deltas, update_weights, update_bias

//image x (shouldn't be signed), input_weight y
module multiply_by_weights(input [99:0] x, input signed [3:0] y1, input signed [3:0] y2, input signed [3:0] y3, input signed [3:0] y4, input signed [3:0] y5, input signed [3:0] y6, input signed [3:0] y7, input signed [3:0] y8, input signed [3:0] y9, input signed [3:0] y10, output signed [9:0] z1, output signed [9:0] z2, output signed [9:0] z3, output signed [9:0] z4, output signed [9:0] z5, output signed [9:0] z6, output signed [9:0] z7, output signed [9:0] z8, output signed [9:0] z9, output signed [9:0] z10);

	assign z1  = x[99]*y1 + x[98]*y2 + x[97]*y3 + x[96]*y4 + x[95]*y5 + x[94]*y6 + x[93]*y7 + x[92]*y8 + x[91]*y9 + x[90]*y10;
	assign z2  = x[89]*y1 + x[88]*y2 + x[87]*y3 + x[86]*y4 + x[85]*y5 + x[84]*y6 + x[83]*y7 + x[82]*y8 + x[81]*y9 + x[80]*y10;
	assign z3  = x[79]*y1 + x[78]*y2 + x[77]*y3 + x[76]*y4 + x[75]*y5 + x[74]*y6 + x[73]*y7 + x[72]*y8 + x[71]*y9 + x[70]*y10;
	assign z4  = x[69]*y1 + x[68]*y2 + x[67]*y3 + x[66]*y4 + x[65]*y5 + x[64]*y6 + x[63]*y7 + x[62]*y8 + x[61]*y9 + x[60]*y10;
	assign z5  = x[59]*y1 + x[58]*y2 + x[57]*y3 + x[56]*y4 + x[55]*y5 + x[54]*y6 + x[53]*y7 + x[52]*y8 + x[51]*y9 + x[50]*y10;
	assign z6  = x[49]*y1 + x[48]*y2 + x[47]*y3 + x[46]*y4 + x[45]*y5 + x[44]*y6 + x[43]*y7 + x[42]*y8 + x[41]*y9 + x[40]*y10;
	assign z7  = x[39]*y1 + x[38]*y2 + x[37]*y3 + x[36]*y4 + x[35]*y5 + x[34]*y6 + x[33]*y7 + x[32]*y8 + x[31]*y9 + x[30]*y10;
	assign z8  = x[29]*y1 + x[28]*y2 + x[27]*y3 + x[26]*y4 + x[25]*y5 + x[24]*y6 + x[23]*y7 + x[22]*y8 + x[21]*y9 + x[20]*y10;
	assign z9  = x[19]*y1 + x[18]*y2 + x[17]*y3 + x[16]*y4 + x[15]*y5 + x[14]*y6 + x[13]*y7 + x[12]*y8 + x[11]*y9 + x[10]*y10;
	assign z10 = x[9]*y1 + x[8]*y2 + x[7]*y3 + x[6]*y4 + x[5]*y5 + x[4]*y6 + x[3]*y7 + x[2]*y8 + x[1]*y9 + x[0]*y10;

endmodule

//output from multiply_by_weights x, input_bias y
module add_with_bias(input signed [9:0] x1, input signed [9:0] x2, input signed [9:0] x3, input signed [9:0] x4, input signed [9:0] x5, input signed [9:0] x6, input signed [9:0] x7, input signed [9:0] x8, input signed [9:0] x9, input signed [9:0] x10, input signed [9:0] y1, input signed [9:0] y2, input signed [9:0] y3, input signed [9:0] y4, input signed [9:0] y5, input signed [9:0] y6, input signed [9:0] y7, input signed [9:0] y8, input signed [9:0] y9, input signed [9:0] y10, output signed [9:0] z1, output signed [9:0] z2, output signed [9:0] z3, output signed [9:0] z4, output signed [9:0] z5, output signed [9:0] z6, output signed [9:0] z7, output signed [9:0] z8, output signed [9:0] z9, output signed [9:0] z10);

	assign z1  = x1 + y1;
	assign z2  = x2 + y2;
	assign z3  = x3 + y3;
	assign z4  = x4 + y4;
	assign z5  = x5 + y5;
	assign z6  = x6 + y6;
	assign z7  = x7 + y7;
	assign z8  = x8 + y8;
	assign z9  = x9 + y9;
	assign z10 = x10 + y10;

endmodule

//output from add_with_bias x, I don't think the output should be signed
//There are three submodules to this activation_function module
module activation_function(input signed [9:0] x1, input signed [9:0] x2, input signed [9:0] x3, input signed [9:0] x4, input signed [9:0] x5, input signed [9:0] x6, input signed [9:0] x7, input signed [9:0] x8, input signed [9:0] x9, input signed [9:0] x10, output [9:0] y);

	wire [3:0] greatestIndex;
	biggestOut findBiggest(
	.in1(x1),
	.in2(x2),
	.in3(x3),
	.in4(x4),
	.in5(x5),
	.in6(x6),
	.in7(x7),
	.in8(x8),
	.in9(x9),
	.in10(x10),
	.biggestIndex(greatestIndex));
	onehot OHC1(
	.greatestIndex(greatestIndex),
	.ohc(y));

endmodule

module biggestOut (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, biggestIndex);
	input signed [9:0] in1;
	input signed [9:0] in2;
	input signed [9:0] in3;
	input signed [9:0] in4;
	input signed [9:0] in5;
	input signed [9:0] in6;
	input signed [9:0] in7;
	input signed [9:0] in8;
	input signed [9:0] in9;
	input signed [9:0] in10;
	output wire [3:0] biggestIndex;
	wire [9:0] tempValue1 [4:0];
	wire [3:0] tempIndex1 [4:0];
	// Find the bigger value between 0 and 1
	comparator C1 (.x1(in1),.indexX1(4'b0000),
	.x2(in2),.indexX2(4'b0001),
	.y(tempValue1[0]),.indexY(tempIndex1[0])
	);
	// Find the bigger value between 2 and 3
	comparator C2 (.x1(in3),.indexX1(4'b0010),
	.x2(in4),.indexX2(4'b0011),
	.y(tempValue1[1]),.indexY(tempIndex1[1])
	);
	// Find the bigger value between 4 and 5
	comparator C3 (.x1(in5),.indexX1(4'b0100),
	.x2(in6),.indexX2(4'b0101),
	.y(tempValue1[2]),.indexY(tempIndex1[2])
	);
	// Find the bigger value between 6 and 7
	comparator C4 (.x1(in7),.indexX1(4'b0110),
	.x2(in8),.indexX2(4'b0111),
	.y(tempValue1[3]),.indexY(tempIndex1[3])
	);
	// Find the bigger value between 8 and 9
	comparator C5 (.x1(in9),.indexX1(4'b1000),
	.x2(in10),.indexX2(4'b1001),
	.y(tempValue1[4]),.indexY(tempIndex1[4])
	);
	wire [9:0] tempValue2 [3:0];
	wire [3:0] tempIndex2 [3:0];
	assign tempValue2[0] = tempValue1[0]; assign tempIndex2[0] = tempIndex1[0];
	assign tempValue2[1] = tempValue1[1]; assign tempIndex2[1] = tempIndex1[1];
	assign tempValue2[2] = tempValue1[2]; assign tempIndex2[2] = tempIndex1[2];
	comparator C6 (.x1(tempValue1[3]),.indexX1(tempIndex1[3]),
	.x2(tempValue1[4]),.indexX2(tempIndex1[4]),
	.y(tempValue2[3]),.indexY(tempIndex2[3])
	);
	wire [9:0] tempValue3 [1:0];
	wire [3:0] tempIndex3 [1:0];
	// Find the bigger value between the 
	comparator C7 (.x1(tempValue2[0]),.indexX1(tempIndex2[0]),
	.x2(tempValue2[1]),.indexX2(tempIndex2[1]),
	.y(tempValue3[0]),.indexY(tempIndex3[0])
	); 
	comparator C8 (.x1(tempValue2[2]),.indexX1(tempIndex2[2]),
	.x2(tempValue2[3]),.indexX2(tempIndex2[3]),
	.y(tempValue3[1]),.indexY(tempIndex3[1])
	);
	wire [9:0] tempValue4;
	wire [3:0] tempIndex4;
	// Find the biggest value
	comparator C9 (.x1(tempValue3[0]),.indexX1(tempIndex3[0]),
	.x2(tempValue3[1]),.indexX2(tempIndex3[1]),
	.y(tempValue4),.indexY(tempIndex4)
	);
	assign biggestIndex = tempIndex4;
endmodule

module comparator (x1, indexX1, x2, indexX2, y, indexY);
	input wire [9:0] x1;
	input wire [3:0] indexX1;
	input wire [9:0] x2;
	input wire [3:0] indexX2;
	output reg [9:0] y;
	output reg [3:0] indexY;
	always@(*) begin
		if (x1[9] > x2[9]) begin
			y = x2;
			indexY = indexX2;
		end
		else if (x1[9] < x2[9]) begin
			y = x1;
			indexY = indexX1;
		end
		else begin
			if (x1[8:0] > x2[8:0]) begin
				y = x1;
				indexY = indexX1;
			end
			else begin
				y = x2;
				indexY = indexX2;
			end
		end
	end
endmodule

module onehot (greatestIndex, ohc);
	input [3:0] greatestIndex;
	output reg [9:0] ohc;
	always@(*) begin
		case (greatestIndex)
			4'b0000: begin
				ohc = 10'b1000000000;
			end
			4'b0001: begin
				ohc = 10'b0100000000;
			end
			4'b0010: begin
				ohc = 10'b0010000000;
			end
			4'b0011: begin
				ohc = 10'b0001000000;
			end
			4'b0100: begin
				ohc = 10'b0000100000;
			end
			4'b0101: begin
				ohc = 10'b0000010000;
			end
			4'b0110: begin
				ohc = 10'b0000001000;
			end
			4'b0111: begin
				ohc = 10'b0000000100;
			end
			4'b1000: begin
				ohc = 10'b0000000010;
			end
			4'b1001: begin
				ohc = 10'b0000000001;
			end
			default: begin
				ohc = 10'b0000000000;
			end
		endcase
	end
endmodule

//output from add_with_bias x, output from activation_function y (only one), expected_matrix m
module derivatives(input signed [9:0] x1, input signed [9:0] x2, input signed [9:0] x3, input signed [9:0] x4, input signed [9:0] x5, input signed [9:0] x6, input signed [9:0] x7, input signed [9:0] x8, input signed [9:0] x9, input signed [9:0] x10, input [9:0] y, input [9:0] m, output signed [9:0] z1, output signed [9:0] z2, output signed [9:0] z3, output signed [9:0] z4, output signed [9:0] z5, output signed [9:0] z6, output signed [9:0] z7, output signed [9:0] z8, output signed [9:0] z9, output signed [9:0] z10);

	//This is a very stupid problem. For some reason slicing and computation doesn't work at the same time
	wire signed [19:0] a1;
	wire signed [19:0] a2;
	wire signed [19:0] a3;
	wire signed [19:0] a4;
	wire signed [19:0] a5;
	wire signed [19:0] a6;
	wire signed [19:0] a7;
	wire signed [19:0] a8;
	wire signed [19:0] a9;
	wire signed [19:0] a10;
	assign a1  = x1 * (m - y);
	assign z1  = a1[14:5];
	assign a2  = x2 * (m - y);
	assign z2  = a2[14:5];
	assign a3  = x3 * (m - y);
	assign z3  = a3[14:5];
	assign a4  = x4 * (m - y);
	assign z4  = a4[14:5];
	assign a5  = x5 * (m - y);
	assign z5  = a5[14:5];
	assign a6  = x6 * (m - y);
	assign z6  = a6[14:5];
	assign a7  = x7 * (m - y);
	assign z7  = a7[14:5];
	assign a8  = x8 * (m - y);
	assign z8  = a8[14:5];
	assign a9  = x9 * (m - y);
	assign z9  = a9[14:5];
	assign a10 = x10 * (m - y);
	assign z10 = a10[14:5];

endmodule

//output from derivatives d, output from add_with_bias x, output from activation_function y
module deltas(input signed [9:0] d1, input signed [9:0] d2, input signed [9:0] d3, input signed [9:0] d4, input signed [9:0] d5, input signed [9:0] d6, input signed [9:0] d7, input signed [9:0] d8, input signed [9:0] d9, input signed [9:0] d10, input signed [9:0] x1, input signed [9:0] x2, input signed [9:0] x3, input signed [9:0] x4, input signed [9:0] x5, input signed [9:0] x6, input signed [9:0] x7, input signed [9:0] x8, input signed [9:0] x9, input signed [9:0] x10, input [9:0] y, output signed [9:0] z1, output signed [9:0] z2, output signed [9:0] z3, output signed [9:0] z4, output signed [9:0] z5, output signed [9:0] z6, output signed [9:0] z7, output signed [9:0] z8, output signed [9:0] z9, output signed [9:0] z10);

	wire signed [19:0] a1;
	wire signed [19:0] a2;
	wire signed [19:0] a3;
	wire signed [19:0] a4;
	wire signed [19:0] a5;
	wire signed [19:0] a6;
	wire signed [19:0] a7;
	wire signed [19:0] a8;
	wire signed [19:0] a9;
	wire signed [19:0] a10;
	assign a1  = d1 * (y - x1);
	assign z1  = a1[14:5];
	assign a2  = d2 * (y - x2);
	assign z2  = a2[14:5];
	assign a3  = d3 * (y - x3);
	assign z3  = a3[14:5];
	assign a4  = d4 * (y - x4);
	assign z4  = a4[14:5];
	assign a5  = d5 * (y - x5);
	assign z5  = a5[14:5];
	assign a6  = d6 * (y - x6);
	assign z6  = a6[14:5];
	assign a7  = d7 * (y - x7);
	assign z7  = a7[14:5];
	assign a8  = d8 * (y - x8);
	assign z8  = a8[14:5];
	assign a9  = d9 * (y - x9);
	assign z9  = a9[14:5];
	assign a10 = d10 * (y - x10);
	assign z10 = a10[14:5];

endmodule

//output from deltas d, input_weight w, output from add_with_bias x
module update_weights(input signed [9:0] d1, input signed [9:0] d2, input signed [9:0] d3, input signed [9:0] d4, input signed [9:0] d5, input signed [9:0] d6, input signed [9:0] d7, input signed [9:0] d8, input signed [9:0] d9, input signed [9:0] d10, input signed [3:0] w1, input signed [3:0] w2, input signed [3:0] w3, input signed [3:0] w4, input signed [3:0] w5, input signed [3:0] w6, input signed [3:0] w7, input signed [3:0] w8, input signed [3:0] w9, input signed [3:0] w10, input signed [9:0] x1, input signed [9:0] x2, input signed [9:0] x3, input signed [9:0] x4, input signed [9:0] x5, input signed [9:0] x6, input signed [9:0] x7, input signed [9:0] x8, input signed [9:0] x9, input signed [9:0] x10, output signed [3:0] z1, output signed [3:0] z2, output signed [3:0] z3, output signed [3:0] z4, output signed [3:0] z5, output signed [3:0] z6, output signed [3:0] z7, output signed [3:0] z8, output signed [3:0] z9, output signed [3:0] z10);

	wire signed [19:0] a1;
	wire signed [19:0] a2;
	wire signed [19:0] a3;
	wire signed [19:0] a4;
	wire signed [19:0] a5;
	wire signed [19:0] a6;
	wire signed [19:0] a7;
	wire signed [19:0] a8;
	wire signed [19:0] a9;
	wire signed [19:0] a10;
	assign a1  = d1 * x1;
	assign z1  = w1 - a1[11:8];
	assign a2  = d2 * x2;
	assign z2  = w2 - a2[11:8];
	assign a3  = d3 * x3;
	assign z3  = w3 - a3[11:8];
	assign a4  = d4 * x4;
	assign z4  = w4 - a4[11:8];
	assign a5  = d5 * x5;
	assign z5  = w5 - a5[11:8];
	assign a6  = d6 * x6;
	assign z6  = w6 - a6[11:8];
	assign a7  = d7 * x7;
	assign z7  = w7 - a7[11:8];
	assign a8  = d8 * x8;
	assign z8  = w8 - a8[11:8];
	assign a9  = d9 * x9;
	assign z9  = w9 - a9[11:8];
	assign a10 = d10 * x10;
	assign z10 = w10 - a10[11:8];

endmodule

//output from deltas d
module update_bias(input signed [9:0] d1, input signed [9:0] d2, input signed [9:0] d3, input signed [9:0] d4, input signed [9:0] d5, input signed [9:0] d6, input signed [9:0] d7, input signed [9:0] d8, input signed [9:0] d9, input signed [9:0] d10, output signed [9:0] z1, output signed [9:0] z2, output signed [9:0] z3, output signed [9:0] z4, output signed [9:0] z5, output signed [9:0] z6, output signed [9:0] z7, output signed [9:0] z8, output signed [9:0] z9, output signed [9:0] z10);

	assign z1  = d1;
	assign z2  = d2;
	assign z3  = d3;
	assign z4  = d4;
	assign z5  = d5;
	assign z6  = d6;
	assign z7  = d7;
	assign z8  = d8;
	assign z9  = d9;
	assign z10 = d10;

endmodule

//Thank you for your attention